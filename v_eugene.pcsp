/*
Naming conventions: 
	processes are PascalCase and start with _
	events are PascalCase and do not start with _
	variables are snake_case
*/

// +-----+-----+-----+-----+-----+
// |     |  2  |  3  |  4  |     |
// +-----+-----+-----+-----+-----+
// |  1  |  5  |  6  |  7  |  11 |
// +-----+-----+-----+-----+-----+
// |     |  8  |  9  |  10 |     |
// +-----+-----+-----+-----+-----+
// 1 is team 0 goal
// 11 is team 1 goal
// 0 is out of bounds

enum {
	NEUTRAL,
	OFFENSIVE,
	DEFENSIVE
};
hvar maxScore = 100;
var time = 2;
var possession[1] = [1];
var scores[2] = [0,0];
hvar strategies = [NEUTRAL, NEUTRAL];
hvar frozen = false;
hvar ball_position[2] = [0,0];

// each position has a flag that determines 2 player per zone
// if [0,0] -> team 0
// if [0,1] || [1,0] -> does not beloong to either team
// if [1,1] -> team 1
hvar positions[3][3][2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

//hvar zones[3][3][1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

// each zone assign float value from 0 -> 1
// float value determine by weighted average of players from each team

// if zone 5  has 1 team 0 player and 2 team 1 player
// then zone value = (0 + 1 + 1) / 3 = 2/3 

// 10 player each 

// 0 0 0 0 1 / 5 = 0.2, 0.8 chance it belongs to team 0 
// 0 1 1 1 1 / 5 = 0.8, 0.2 chance it belongs to team 0

_Freeze = Freeze { frozen = true; } -> Skip; // process = event -> process
_Unfreeze = Unfreeze { frozen = false; } -> Skip;

hvar shoot_probabilities[4][3] = [
	10, 5, 85, // [Score, HitGoalPost, OutOfBounds]
	20, 5, 75,  // each row must add up to 100
	30, 5, 65,
	25, 5, 70
];

_SetDefaultPositions(team) = SetDefaultPositions.team {
	if (team == 0) {
		positions[0][0][0] = 0;
		positions[0][0][1] = 0;
		
		positions[1][0][0] = 0;
		positions[1][0][1] = 0;
		
		positions[2][0][0] = 0;
		positions[2][0][1] = 0;
		
	} else if (team == 1) {
	
		positions[0][2][0] = 1;
		positions[0][2][1] = 1;
		
		positions[1][2][0] = 1;
		positions[1][2][1] = 1;
		
		positions[2][2][0] = 1;
		positions[2][2][1] = 1;
		
	
	} 
} -> Skip;

_SetMiddlePositions(team) = SetMiddlePositions.team { 
		positions[0][1][0] = team;
		positions[0][1][1] = team;
		
		positions[1][1][0] = team;
		positions[1][1][1] = team;
		
		positions[2][1][0] = team;
		positions[2][1][1] = team;
		
} -> Skip;


_ResetBall = ResetBall {
	ball_position[0] = 1;
	ball_position[1] = 1;
} -> Skip;

_Reset = _ResetBall; (
	[possession[0] == 0] _SetDefaultPositions(1); _SetMiddlePositions(0)
	[]
	[possession[0] == 1] _SetDefaultPositions(0); _SetMiddlePositions(1)
);


_GetPossession(team) = GetPossession.team {
	strategies[team] = OFFENSIVE;
	strategies[(team + 1) % 2] = DEFENSIVE;
	possession[0] = team; 
}->Skip;

_MoveTowardsBall(team) = pcase {
		[0.25]: atomic { TakeOverPosition.team { 
				positions[ball_position[0]][ball_position[1]][team] = team;
				if (team == 0) {		
					positions[ball_position[0]][ball_position[1]][1] = 0;
				} else if (team == 1) {
					positions[ball_position[0]][ball_position[1]][0] = 1;
				} 
				} -> Skip } 
		[0.75]: atomic { LoseThatPosition.team{ 
				positions[ball_position[0]][ball_position[1]][team] = team;
				if (team == 0) {		
					positions[ball_position[0]][ball_position[1]][0] = 1;
				} else if (team == 1) {
					positions[ball_position[0]][ball_position[1]][1] = 0;
				} 
				
				} -> Skip }
	}  ;
 

_MoveTowardsOpponentGoal(team) = // offensive team 
	MoveTowardOpponentGoal.team {
		if (team == 0 && ball_position[1] < 2) {
			// move right
			ball_position[1] = ball_position[1]++;
		} else if (team == 1 && ball_position[1] > 0) {
			// move left
			ball_position[1] = ball_position[1]--;
		}  
	} -> Skip;
 


_Move(team) = [strategies[team] == NEUTRAL]  _MoveTowardsBall(team);   ([positions[ball_position[0]][ball_position[1]][0] == team  && positions[ball_position[0]][ball_position[1]][1] == team  ] atomic { _GetPossession(team) }
			  														  []
			  														  [!frozen] atomic { Wait.team -> Skip }) 
			  [] 
			  [strategies[team] == OFFENSIVE] _MoveTowardsOpponentGoal(team) 
			  []
			  [strategies[team] == DEFENSIVE]  _MoveTowardsBall(team); ([positions[ball_position[0]][ball_position[1]][0] == team  && positions[ball_position[0]][ball_position[1]][1] == team  ] atomic { _GetPossession(team) }
			  														  []
			  														  [!frozen] atomic { Wait.team -> Skip } 
			  )
			  ;
 
_ChangePossession =
	[possession[0] == 0] _GetTeamPossession(1) // call this to flip ownership
	[]
	[possession[0] == 1] _GetTeamPossession(0)
;

_Shoot(team) = pcase {
	shoot_probabilities[team][0]: atomic { Score.team { scores[team]++; } -> _Freeze; _ChangePossession; _Reset }
	shoot_probabilities[team][1]: atomic { HitGoalPost.team -> _LooseBall }
	shoot_probabilities[team][2]: atomic { OutOfBounds.team -> GoalKick.team -> _LooseBall }
};

_LooseBall = atomic { LosePossession { 
	possession[0] = -1;
	strategies[0] = NEUTRAL;
	strategies[1] = NEUTRAL;
} -> pcase {
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 0; } -> Skip
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 1; } -> Skip
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 2; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 0; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 1; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 2; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 0; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 1; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 2; } -> Skip
}};

_TakeTeamAction(team) =   
	[!frozen && (possession[0] != team) ] atomic { _Move(team) }
	[]
	[!frozen && possession[0] == team] atomic { _Shoot(team) }
	[]
	[frozen] Wait.team -> Skip;


_Tackle(team) = pcase {
	[0.2]: atomic { SuccessfulTackle.team -> _GetPossession(team) } // cannot execute another process halfway
	[0.8]: atomic { UnsuccessfulTackle.team -> Skip }
};


_GetTeamPossession(team) =  _GetPossession(team); 

_TakeAction = // both teams take action at the same time
	[time > 0 && scores[0] < maxScore && scores[1] < maxScore] Tick { time--; } -> _Unfreeze; (_TakeTeamAction(0) ||| _TakeTeamAction(1)); _TakeAction
	[]
	[time <= 0 || scores[0] >= maxScore || scores[1] >= maxScore] Skip;

_DecideFirstPossession = []team:{0, 1} @ _GetTeamPossession(team);

_PlayGame = _DecideFirstPossession; _Reset; _TakeAction;

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert _PlayGame reaches FirstTeamWin;
#assert _PlayGame reaches SecondTeamWin;
#assert _PlayGame reaches Draw;

#assert _PlayGame reaches FirstTeamWin with prob;
#assert _PlayGame reaches SecondTeamWin with prob;
#assert _PlayGame reaches Draw with prob;

#assert _PlayGame deadlockfree;