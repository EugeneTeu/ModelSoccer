/*
Naming conventions: 
	processes are PascalCase and start with _
	events are PascalCase and do not start with _
	variables are snake_case
*/

// +-----+-----+-----+-----+-----+
// |     |  2  |  3  |  4  |     |
// +-----+-----+-----+-----+-----+
// |  1  |  5  |  6  |  7  |  11 |
// +-----+-----+-----+-----+-----+
// |     |  8  |  9  |  10 |     |
// +-----+-----+-----+-----+-----+
// 1 is team 0 goal
// 11 is team 1 goal
// 0 is out of bounds

enum {
	NEUTRAL,
	OFFENSIVE,
	DEFENSIVE
};
hvar maxScore = 5;
var time = 2;
var possession[1] = [1];
var scores[2] = [0,0];
hvar strategies = [NEUTRAL, NEUTRAL];
hvar frozen = false;
hvar ball_position[2] = [0,0];

// each position has a flag that determines 2 player per zone
// if [0,0] -> team 0
// if [0,1] || [1,0] -> does not beloong to either team
// if [1,1] -> team 1
hvar positions[3][3][2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

_Freeze = Freeze { frozen = true; } -> Skip; // process = event -> process
_Unfreeze = Unfreeze { frozen = false; } -> Skip;

hvar shoot_probabilities[4][3] = [
	10, 5, 85, // [Score, HitGoalPost, OutOfBounds]
	20, 5, 75,  // each row must add up to 100
	30, 5, 65,
	25, 5, 70
];

_SetDefaultPositions(team) = SetDefaultPositions.team {
	if (team == 0) {
		positions[0][0][0] = 0;
		positions[0][0][1] = 0;
		
		positions[1][0][0] = 0;
		positions[1][0][1] = 0;
		
		positions[2][0][0] = 0;
		positions[2][0][1] = 0;
		
	} else if (team == 1) {
	
		positions[0][2][0] = 1;
		positions[0][2][1] = 1;
		
		positions[1][2][0] = 1;
		positions[1][2][1] = 1;
		
		positions[2][2][0] = 1;
		positions[2][2][1] = 1;
		
	
	} 
} -> Skip;

_SetMiddlePositions(team) = SetMiddlePositions.team { 
		positions[0][1][0] = team;
		positions[0][1][1] = team;
		
		positions[1][1][0] = team;
		positions[1][1][1] = team;
		
		positions[2][1][0] = team;
		positions[2][1][1] = team;
		
} -> Skip;


_ResetBall = ResetBall {
	ball_position[0] = 1;
	ball_position[1] = 1;
} -> Skip;

_Reset = _ResetBall; (
	[possession[0] == 0] _SetDefaultPositions(1); _SetMiddlePositions(0)
	[]
	[possession[0] == 1] _SetDefaultPositions(0); _SetMiddlePositions(1)
);


_GetPossession(team) = GetPossession.team {
	strategies[team] = OFFENSIVE;
	strategies[(team + 1) % 2] = DEFENSIVE;
	possession[0] = team; 
}->Skip;

_MoveTowardsBall(team) = MoveTowardBall.team {
	
		//var currentBallRow = ball_position[0];
		//var currentBallCol = ball_position[1];
		// send a player to get the ball 
		positions[ball_position[0]][ball_position[1]][team] = team;
		
	} -> pcase {
		[0.25]:  TakeOverPosition.team { 
				if (team == 0) {		
					positions[ball_position[0]][ball_position[1]][1] = 0;
				} else if (team == 1) {
					positions[ball_position[0]][ball_position[1]][0] = 1;
				} 
				} -> Skip 
		[0.75]: LoseThatPosition.team{ 
				if (team == 0) {		
					positions[ball_position[0]][ball_position[1]][0] = 1;
				} else if (team == 1) {
					positions[ball_position[0]][ball_position[1]][1] = 0;
				} 
				
				} -> Skip
	} ;
 

_MoveTowardsOpponentGoal(team) = // offensive team 
	MoveTowardOpponentGoal.team {
		if (team == 0 && ball_position[1] < 2) {
			// move right
			ball_position[1] = ball_position[1]++;
		} else if (team == 1 && ball_position[1] > 0) {
			// move left
			ball_position[1] = ball_position[1]--;
		}  
	} -> Skip;
 


_Move(team) = [strategies[team] == NEUTRAL] _MoveTowardsBall(team);  ([positions[ball_position[0]][ball_position[1]][0] == team  && positions[ball_position[0]][ball_position[1]][1] == team  ] atomic { _GetPossession(team) }
			  														  []
			  														  [!frozen] atomic { Wait.team -> Skip })
			  [] 
			  [strategies[team] == OFFENSIVE] _MoveTowardsOpponentGoal(team)
			  []
			  [strategies[team] == DEFENSIVE]  _MoveTowardsBall(team); ([positions[ball_position[0]][ball_position[1]][0] == team  && positions[ball_position[0]][ball_position[1]][1] == team  ] atomic { _Tackle(team) }
			  														  []
			  														  [!frozen] atomic { Wait.team -> Skip }
			  )
			  ;
 
_ChangePossession =
	[possession[0] == 0] _GetTeamPossession(1) // call this to flip ownership
	[]
	[possession[0] == 1] _GetTeamPossession(0)
;

_Shoot(team) = pcase {
	shoot_probabilities[team][0]: atomic { Score.team { scores[team]++; } -> _Freeze; _ChangePossession; _Reset }
	shoot_probabilities[team][1]: atomic { HitGoalPost.team -> _LooseBall }
	shoot_probabilities[team][2]: atomic { OutOfBounds.team -> GoalKick.team -> _LooseBall }
};

_LooseBall = atomic { LosePossession { 
	possession[0] = -1;
	strategies[0] = NEUTRAL;
	strategies[1] = NEUTRAL;
} -> pcase {
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 0; } -> Skip
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 1; } -> Skip
	1: SetBall.0 { ball_position[0] = 0; ball_position[1] = 2; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 0; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 1; } -> Skip
	1: SetBall.1 { ball_position[0] = 1; ball_position[1] = 2; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 0; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 1; } -> Skip
	1: SetBall.2 { ball_position[0] = 2; ball_position[1] = 2; } -> Skip
}};

_TakeTeamAction(team) =   
	[!frozen && (possession[0] != team) ] _Move(team)
	[]
	[!frozen && possession[0] == team] _Shoot(team)
	[]
	[frozen] Wait.team -> Skip;


_Tackle(team) = pcase {
	[0.2]: atomic { SuccessfulTackle.team -> _GetPossession(team) } // cannot execute another process halfway
	[0.8]: atomic { UnsuccessfulTackle.team -> Skip }
};


_GetTeamPossession(team) =  _GetPossession(team); 

_TakeAction = // both teams take action at the same time
	[time > 0 && scores[0] < maxScore && scores[1] < maxScore] Tick { time--; } -> _Unfreeze; (_TakeTeamAction(0) || _TakeTeamAction(1)); _TakeAction
	[]
	[time <= 0 || scores[0] >= maxScore || scores[1] >= maxScore] Skip;

_DecideFirstPossession = []team:{0, 1} @ _GetTeamPossession(team);

_PlayGame = _DecideFirstPossession; _Reset; _TakeAction;

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert _PlayGame reaches FirstTeamWin;
#assert _PlayGame reaches SecondTeamWin;
#assert _PlayGame reaches Draw;

#assert _PlayGame reaches FirstTeamWin with prob;
#assert _PlayGame reaches SecondTeamWin with prob;
#assert _PlayGame reaches Draw with prob;

#assert _PlayGame deadlockfree;

//var time = 2;
//hvar ball_position[2] = [1, 1];
//var possession[2] = [-1, -1]; // initially, undecided possession, [team, player holding ball]
//var scores = [0, 0];
//hvar positions[2][11][2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; // T player [row or col] -> 0 , 1 refers to row or col 
//hvar shoot_probabilities[4][3] = [
//	10, 5, 85, // [Score, HitGoalPost, OutOfBounds]
//	20, 5, 75,  // each row must add up to 100
//	30, 5, 65,
//	25, 5, 70
//];
//hvar strategies = [NEUTRAL, NEUTRAL];
//hvar frozen = false;
//
//_Freeze = Freeze { frozen = true; } -> Skip; // process = event -> process
//_Unfreeze = Unfreeze { frozen = false; } -> Skip;
//
//_ResetBall = ResetBall {
//	ball_position[0] = 1;
//	ball_position[1] = 1;
//} -> Skip;
//
//_SetDefaultPositions(team) = SetDefaultPositions.team {
//	if (team == 0) {
//		positions[0][0][0] = 0; // zero player on team 0 his row is at 0
//		positions[0][0][1] = 0; // zero player on team 0 his col is at 0
//		
//		positions[0][1][0] = 2;
//		positions[0][1][1] = 0;
//		
//		positions[0][2][0] = 1;
//		positions[0][2][1] = 0;
//		
//		positions[0][3][0] = 0;
//		positions[0][3][1] = 1;
//		
//		positions[0][4][0] = 0; // zero player on team 0 his row is at 0
//		positions[0][4][1] = 0; // zero player on team 0 his col is at 0
//		
//		positions[0][5][0] = 2;
//		positions[0][5][1] = 0;
//		
//		positions[0][6][0] = 1;
//		positions[0][6][1] = 0;
//		
//		positions[0][7][0] = 0;
//		positions[0][7][1] = 1;
//		
//		positions[0][8][0] = 0; // zero player on team 0 his row is at 0
//		positions[0][8][1] = 0; // zero player on team 0 his col is at 0
//		
//		positions[0][9][0] = 2;
//		positions[0][9][1] = 0;
//		
//		positions[0][10][0] = 1;
//		positions[0][10][1] = 0;
//
//	} else if (team == 1) {
//		positions[1][0][0] = 0;
//		positions[1][0][1] = 2;
//		
//		positions[1][1][0] = 2;
//		positions[1][1][1] = 2;
//		
//		positions[1][2][0] = 1;
//		positions[1][2][1] = 2;
//		
//		positions[1][3][0] = 2;
//		positions[1][3][1] = 1;
//		
//		positions[1][4][0] = 0;
//		positions[1][4][1] = 2;
//		
//		positions[1][5][0] = 2;
//		positions[1][5][1] = 2;
//		
//		positions[1][6][0] = 1;
//		positions[1][6][1] = 2;
//		
//		positions[1][7][0] = 2;
//		positions[1][7][1] = 1;
//		
//		positions[1][8][0] = 0;
//		positions[1][8][1] = 2;
//		
//		positions[1][9][0] = 2;
//		positions[1][9][1] = 2;
//		
//		positions[1][10][0] = 1;
//		positions[1][10][1] = 2;
//		
//	}
//} -> Skip;
//
//_SetKickoffPositions(team) = SetKickoffPositions.team {
//	positions[team][0][0] = 1;
//	positions[team][0][1] = 1;
//	
//	positions[team][1][0] = 1;
//	positions[team][1][1] = 1;
//	
//	positions[team][2][0] = 1;
//	positions[team][2][1] = 1;
//	
//	positions[team][3][0] = 1;
//	positions[team][3][1] = 1;
//	
//	positions[team][4][0] = 1;
//	positions[team][4][1] = 1;
//	
//	positions[team][5][0] = 1;
//	positions[team][5][1] = 1;
//	
//	positions[team][6][0] = 1;
//	positions[team][6][1] = 1;
//	
//	positions[team][7][0] = 1;
//	positions[team][7][1] = 1;
//	
//	positions[team][8][0] = 1;
//	positions[team][8][1] = 1;
//	
//	positions[team][9][0] = 1;
//	positions[team][9][1] = 1;
//	
//	positions[team][10][0] = 1;
//	positions[team][10][1] = 1;
//	
//} -> Skip;
//
//_Reset = _ResetBall; (
//	[possession[0] == 0] _SetDefaultPositions(1); _SetKickoffPositions(0)
//	[]
//	[possession[0] == 1] _SetDefaultPositions(0); _SetKickoffPositions(1)
//);
//
//// _Reset process, then execute the next 
//
//_GetTeamPossession(team) = []player:{0,1,2,3,4,5} @ _GetPossession(team, player); // _GetPossesion has a parameter player with choice either 0 or 1. 
//
//_GetPossession(team, player) = GetPossession.team.player {
//	// We update strategies here so that this process can be directly used
//	strategies[team] = OFFENSIVE;
//	strategies[(team + 1) % 2] = DEFENSIVE;
//	possession[0] = team; 
//	possession[1] = player;
//} -> Skip;
//
//_ChangePossession =
//	[possession[0] == 0] _GetTeamPossession(1) // call this to flip ownership
//	[]
//	[possession[0] == 1] _GetTeamPossession(0)
//;
//
//_DribbleLeft(team, player) = DribbleLeft.team.player {
//	ball_position[1]--;
//	positions[team][player][1]--;
//} -> Skip;
//
//_DribbleUp(team, player) = DribbleUp.team.player {
//	ball_position[0]--;
//	positions[team][player][0]--;
//} -> Skip;
//
//_DribbleRight(team, player) = DribbleRight.team.player {
//	ball_position[1]++;
//	positions[team][player][1]++;
//} -> Skip;
//
//_DribbleDown(team, player) = DribbleDown.team.player {
//	ball_position[0]++;
//	positions[team][player][0]++;
//} -> Skip;
//
//_DribbleUpLeft(team, player) = DribbleUpLeft.team.player {
//	ball_position[0]--;
//	ball_position[1]--;
//	positions[team][player][0]--;
//	positions[team][player][1]--;
//} -> Skip;
//
//_DribbleUpRight(team, player) = DribbleUpRight.team.player {
//	ball_position[0]--;
//	ball_position[1]++;
//	positions[team][player][0]--;
//	positions[team][player][1]++;
//} -> Skip;
//
//_DribbleDownLeft(team, player) = DribbleDownLeft.team.player {
//	ball_position[0]++;
//	ball_position[1]--;
//	positions[team][player][0]++;
//	positions[team][player][1]--;
//} -> Skip;
//
//_DribbleDownRight(team, player) = DribbleDownRight.team.player {
//	ball_position[0]++;
//	ball_position[1]++;
//	positions[team][player][0]++;
//	positions[team][player][1]++;
//} -> Skip;
//
//_DribbleTowardsOpponentGoal(team, player) =
//	[team == 0 && positions[team][player][1] != 2] _DribbleRight(team, player)
//	[]
//	[team == 0 && positions[team][player][1] == 2] Stay.team.player -> Skip
//	[]
//	[team == 1 && positions[team][player][1] != 0] _DribbleLeft(team, player)
//	[]
//	[team == 1 && positions[team][player][1] == 0] Stay.team.player -> Skip
//;
//
//_Dribble(team, player) = 
//	// Right now, any player who has the right to dribble must be in OFFENSIVE mode
//	[strategies[team] == NEUTRAL] Skip
//	[]
//	[strategies[team] == OFFENSIVE] _DribbleTowardsOpponentGoal(team, player)
//	[]
//	[strategies[team] == DEFENSIVE] Skip
//;
//
//_Tackle(team, player) = pcase {
//	[0.2]: atomic { SuccessfulTackle.team.player -> _GetPossession(team, player) } // cannot execute another process halfway
//	[0.8]: atomic { UnsuccessfulTackle.team.player -> Skip }
//};
//
//_MoveLeft(team, player) = MoveLeft.team.player {
//	positions[team][player][1]--;
//} -> Skip;
//
//_MoveUp(team, player) = MoveUp.team.player {
//	positions[team][player][0]--;
//} -> Skip;
//
//_MoveRight(team, player) = MoveRight.team.player {
//	positions[team][player][1]++;
//} -> Skip;
//
//_MoveDown(team, player) = MoveDown.team.player {
//	positions[team][player][0]++;
//} -> Skip;
//
//_MoveUpLeft(team, player) = MoveUpLeft.team.player {
//	positions[team][player][0]--;
//	positions[team][player][1]--;
//} -> Skip;
//
//_MoveUpRight(team, player) = MoveUpRight.team.player {
//	positions[team][player][0]--;
//	positions[team][player][1]++;
//} -> Skip;
//
//_MoveDownLeft(team, player) = MoveDownLeft.team.player {
//	positions[team][player][0]++;
//	positions[team][player][1]--;
//} -> Skip;
//
//_MoveDownRight(team, player) = MoveDownRight.team.player {
//	positions[team][player][0]++;
//	positions[team][player][1]++;
//} -> Skip;
//
//_MoveTowardsBall(team, player) = // defensive team
//	[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] Stay.team.player -> Skip
//	[]
//	[positions[team][player][0] > ball_position[0] && positions[team][player][1] == ball_position[1]] _MoveUp(team, player)
//	[]
//	[positions[team][player][0] < ball_position[0] && positions[team][player][1] == ball_position[1]] _MoveDown(team, player)
//	[]
//	[positions[team][player][0] == ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveRight(team, player)
//	[]
//	[positions[team][player][0] == ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveLeft(team, player)
//	[]
//	[positions[team][player][0] > ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveUpLeft(team, player)
//	[]
//	[positions[team][player][0] > ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveUpRight(team, player)
//	[]
//	[positions[team][player][0] < ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveDownRight(team, player)
//	[]
//	[positions[team][player][0] < ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveDownLeft(team, player)
//;
//
//_MoveTowardsOpponentGoal(team, player) = // offensive team
//	[team == 0 && positions[team][player][1] != 2] _MoveRight(team, player)
//	[]
//	[team == 0 && positions[team][player][1] == 2] Stay.team.player -> Skip
//	[]
//	[team == 1 && positions[team][player][1] != 0] _MoveLeft(team, player)
//	[]
//	[team == 1 && positions[team][player][1] == 0] Stay.team.player -> Skip
//;
//
//_Move(team, player) = 
//	[strategies[team] == NEUTRAL]
//		_MoveTowardsBall(team, player); (
//			[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] atomic { _GetPossession(team, player) }
//			[]
//			[positions[team][player][0] != ball_position[0] || positions[team][player][1] != ball_position[1]] atomic { Wait.team.player -> Skip }
//		)
//	[]
//	[strategies[team] == OFFENSIVE] _MoveTowardsOpponentGoal(team, player)
//	[]
//	[strategies[team] == DEFENSIVE] 
//		_MoveTowardsBall(team, player); (
//			[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1] ] atomic { _Tackle(team, player) }
//			[]
//			[positions[team][player][0] != ball_position[0] || positions[team][player][1] != ball_position[1]] atomic { Wait.team.player -> Skip }
//		)
//;
//
//_LooseBall = atomic { LosePossession { 
//	possession[0] = -1;
//	possession[1] = -1;
//	strategies[0] = NEUTRAL;
//	strategies[1] = NEUTRAL;
//} -> pcase {
//	1: SetBall.0.0 { ball_position[0] = 0; ball_position[1] = 0; } -> Skip
//	1: SetBall.0.1 { ball_position[0] = 0; ball_position[1] = 1; } -> Skip
//	1: SetBall.0.2 { ball_position[0] = 0; ball_position[1] = 2; } -> Skip
//	1: SetBall.1.0 { ball_position[0] = 1; ball_position[1] = 0; } -> Skip
//	1: SetBall.1.1 { ball_position[0] = 1; ball_position[1] = 1; } -> Skip
//	1: SetBall.1.2 { ball_position[0] = 1; ball_position[1] = 2; } -> Skip
//	1: SetBall.2.0 { ball_position[0] = 2; ball_position[1] = 0; } -> Skip
//	1: SetBall.2.1 { ball_position[0] = 2; ball_position[1] = 1; } -> Skip
//	1: SetBall.2.2 { ball_position[0] = 2; ball_position[1] = 2; } -> Skip
//}};
//// player > 3
//_Shoot(team, player) = pcase {
//	shoot_probabilities[team][0]: atomic { Score.team {
//		scores[team]++;
//	} -> _Freeze; _ChangePossession; _Reset }
//
//	shoot_probabilities[team][1]: atomic { HitGoalPost.team -> _LooseBall }
//	
//	shoot_probabilities[team][2]: atomic { OutOfBounds.team -> GoalKick.team -> _LooseBall }
//};
//
//_TakeTeamAction(team) = ||player:{0,1,2,3,4,5} @ ( // when a team takes action, these actions will occur independently of one another
//	[!frozen && (possession[0] != team || possession[1] != player)] _Move(team, player)
//	[]
//	[!frozen && possession[0] == team && possession[1] == player] _Dribble(team, player)
//	[]
//	[!frozen && possession[0] == team && possession[1] == player && player > 3] _Shoot(team, player)
////	[]
////	[possession[0] == team && possession[1] == player] _Pass(team, player)
//	[]
//	[frozen] Wait.team.player -> Skip
//);
//
//_TakeAction = // both teams take action at the same time
//	[time > 0] Tick { time--; } -> _Unfreeze; (_TakeTeamAction(0) || _TakeTeamAction(1)); _TakeAction
//	[]
//	[time <= 0] Skip;
//
//_DecideFirstPossession = []team:{0, 1} @ _GetTeamPossession(team);
//
//_PlayGame = _DecideFirstPossession; _Reset; _TakeAction;
//
//#define FirstTeamWin scores[0] > scores[1] && time <= 0;
//#define SecondTeamWin scores[1] > scores[0] && time <= 0;
//#define Draw scores[0] == scores[1] && time <= 0;
//
//#assert _PlayGame reaches FirstTeamWin;
//#assert _PlayGame reaches SecondTeamWin;
//#assert _PlayGame reaches Draw;
//
//#assert _PlayGame reaches FirstTeamWin with prob;
//#assert _PlayGame reaches SecondTeamWin with prob;
//#assert _PlayGame reaches Draw with prob;
//
//#assert _PlayGame deadlockfree;