// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |  top |  top |  top |  top |  top |  top |  top |      |
// +------+------+------+------+------+------+------+------+------+
// |  out |corner|      |      |      |      |      |corner|  out |
// | side | kick |      |      |      |      |      | kick | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// | goal | goal |      |      | start|      |      | goal | goal |
// |   A  |  box |      |      |circle|      |      |  box |   B  | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |corner|      |      |      |      |      |corner|  out |
// | side | kick |      |      |      |      |      | kick | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |bottom|bottom|bottom|bottom|bottom|bottom|bottom|      |
// +------+------+------+------+------+------+------+------+------+

// Gameplay: 11 vs 11 (goalie can only move within the goal box)
// Overall grid size = 7 x 9
// out top/bottom - out of bounds cells needed to keep track of throw-in locations
// out side - out of bounds cells to transition into corner-kick/goal-kick events
// goal box - cells where the goalie can move
// corner kick - cells where corner-kick events take place
// start circle - starting ball/player position whenever there are hard resets
// resets - hard or soft, depending on event
// hard resets - where postions of EVERY player are set to fixed positions. Happens for own goal/score/corner-kick events
// soft resets - where positions of SOME players are manually set. Happens for throw-in events

#import "PAT.Lib.SoccerCalc";

#define PlayersPerTeam 10;
#define RowSize 7;
#define ColumnSize 9;

var time = 8;
var possession = -1; // only used as a temp var to perform OtherAction
var ballPlayer = -1;
var ballPosition = [3, 4];
var playerPosition[2][10][2] = [3, 3, 1, 3, 2, 3, 4, 3, 5, 3, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 3, 5, 1, 5, 2, 5, 4, 5, 5, 5, 1, 6, 2, 6, 3, 6, 4, 6, 5, 6];

// private static int[,] goaliePosition = new int[2, 2] { { 3, 1 }, { 3, 7 } };

var scores = [0, 0];
hvar frozen = false;

//////////////////////
// Position setting //
//////////////////////

// To manually set a player position
SetPlayerPosition(team, player, row, col) = SetPlayer.team.player { playerPosition = call(setPlayerPosition, playerPosition, team, player, row, col); } -> Skip;

// To manually set a goalie position
//SetGoaliePosition(team, row, col) = SetGoalie.team { call(setGoaliePosition, team, row, col); } -> Skip;

// To manually set a ball position
SetBallPosition(row, col) = SetBall.row.col { ballPosition[0] = row; ballPosition[1] = col; } -> Skip;

// To manually set possession of ball
SetBallPossession(team) = SetPossession.team { possession = team; } -> Skip;

SetBallPlayer(player) = SetBallP.player { ballPlayer = player; } -> Skip; // implement lib

SetKickOffPosition(team) = SetBallPosition(3, 4); SetBallPossession(team); SetPlayerPosition(team, 0, 3, 4); SetBallPlayer(0); // continue adding

////////////////////
// General action //
////////////////////

DecideFirstPossession() = []possess:{0, 1} @ SetKickOffPosition(possess);

TakeAction() = 
    [time > 0] Tick { time--; } -> Unfreeze { frozen = false; } -> MoveAction(); OtherAction(); TakeAction() //CheckBallEvent()
    []
    [time <= 0] Skip;

//////////////////////
// Movement actions //
//////////////////////

MoveAction() = move { playerPosition = call(move, playerPosition, possession, ballPosition, ballPlayer); } -> Skip;

///////////////////
// Other actions //
//////////////////

RetrieveBall() = |||team:{0, 1} @ Retrieve.team { possession = call(getBall, playerPosition, team, possession, ballPosition); ballPlayer = call(getBallPlayer, playerPosition, possession, ballPosition); } ->  Skip;

OtherAction() = |||team:{0, 1} @ OtherAct.team -> (
	[!frozen && team == possession] atomic { OffensiveAction() }
	[]
	[!frozen && team != possession && possession != -1] atomic { DefensiveAction() }
	[]
	[!frozen && possession == -1] atomic { RetrieveBall() }
	[]
	[frozen] Skip);

DefensiveAction() = pcase {
	call(getTackle, playerPosition, ballPosition, possession): TackleSuccess { ballPlayer = call(getTacklePlayer, playerPosition, ballPosition, possession); if(possession == 1) { possession = 0;} else { possession = 1; } } -> Skip
	call(getDodge, ballPlayer): TackleFail -> Skip
	};

OffensiveAction() = pcase {
	call(getShootProb, ballPlayer, ballPosition, possession): ShootAction -> Shoot() // change to lib call
	call(getPassProb, ballPlayer): PassAction -> Pass() // change to lib call
	1: Drib -> Dribble() 
	1: DoNothing -> Skip
	};

Dribble() = pcase {
	call(getDribbleProb, ballPlayer): atomic { DribbleSuccess { playerPosition = call(dribble, playerPosition, possession, ballPlayer); ballPosition = call(getDribbleBall, playerPosition, ballPlayer, possession); } -> Skip }
	1: DribbleFail { possession = -1; } -> Skip
    };

Shoot() = pcase {
	call(getScoreProb, ballPlayer): ShootScore { scores[possession]++; playerPosition = call(resetPlayerPosition); if(possession == 1) { possession = 0;} else { possession = 1; } } -> Freeze { frozen = true; } -> SetKickOffPosition(possession) // need to reset afterwards
	1: ShootMiss { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1;  } -> Skip // need to change after
	};

Pass() = PassSuccess { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1;  } -> Skip;

PlayMatch = DecideFirstPossession(); TakeAction();

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert PlayMatch reaches FirstTeamWin;
#assert PlayMatch reaches SecondTeamWin;
#assert PlayMatch reaches Draw;

#assert PlayMatch reaches FirstTeamWin with prob;
#assert PlayMatch reaches SecondTeamWin with prob;
#assert PlayMatch reaches Draw with prob;

#assert PlayMatch deadlockfree;