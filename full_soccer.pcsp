// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |  top |  top |  top |  top |  top |  top |  top |      |
// +------+------+------+------+------+------+------+------+------+
// |  out | out  |      |      |      |      |      | out  |  out |
// | side | side |      |      |      |      |      | side | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// | goal | goal |      |      | start|      |      | goal | goal |
// |   A  |  box |      |      |circle|      |      |  box |   B  | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | out  |      |      |      |      |      | out  |  out |
// | side | side |      |      |      |      |      | side | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |bottom|bottom|bottom|bottom|bottom|bottom|bottom|      |
// +------+------+------+------+------+------+------+------+------+

// Gameplay: 11 vs 11 (goalie can only move within the goal box)
// Overall grid size = 7 x 9
// out top/bottom - out of bounds cells needed to keep track of throw-in locations
// out side - out of bounds cells to transition into corner-kick/goal-kick events
// goal box - cells where the goalie can move
// corner kick - cells where corner-kick events take place
// start circle - starting ball/player position whenever there are hard resets
// resets - hard or soft, depending on event
// hard resets - where postions of EVERY player are set to fixed positions. Happens for own goal/score/corner-kick events
// soft resets - where positions of SOME players are manually set. Happens for throw-in events

#import "PAT.Lib.SoccerCalc";

#define NumberOfTeams 2;
#define PlayersPerTeam 10;
#define NumberOfDimensions 2;
#define ROW 0;
#define COL 1;
#define RowSize 7;
#define ColumnSize 9;

var time = 3;
var possession = -1; // only used as a temp var to perform OtherAction
var ballPlayer = -1;
var ballPosition[NumberOfDimensions] = [3, 4];

var playerPositions[NumberOfTeams][PlayersPerTeam][NumberOfDimensions] = 
	// 4-3-3
	[ // Team 0
	2, 4, // Player 0 - left wing striker
	3, 4, // Player 1 - centre striker
	4, 4, // Player 2 - right wing striker
	2, 3, // Player 3 - left wing midfielder
	3, 3, // Player 4 - centre midfielder
	4, 3, // Player 5 - right wing midfielder
	2, 2, // Player 6 - left wing defender
	3, 2, // Player 7 - centre defender
	3, 2, // Player 8 - centre defender
	4, 2, // Player 9 - right wing defender
	  // Team 1
	4, 4, // Player 0 - left wing striker
	3, 4, // Player 1 - centre striker
	2, 4, // Player 2 - right wing striker
	4, 5, // Player 3 - left wing midfielder
	3, 5, // Player 4 - centre midfielder
	2, 5, // Player 5 - right wing midfielder
	4, 6, // Player 6 - left wing defender
	3, 6, // Player 7 - centre defender
	3, 6, // Player 8 - centre defender
	2, 6  // Player 9 - right wing defender
	];
	// 4-4-2
//	[ // Team 0
//	3, 4, // Player 0 - centre striker
//	3, 4, // Player 1 - centre striker
//	2, 3, // Player 2 - left wing midfielder
//	3, 3, // Player 3 - centre midfielder
//	3, 3, // Player 4 - centre midfielder
//	4, 3, // Player 5 - right wing midfielder
//	2, 2, // Player 6 - left wing defender
//	3, 2, // Player 7 - centre defender
//	3, 2, // Player 8 - centre defender
//	4, 2, // Player 9 - right wing defender
//	  // Team 1
//	3, 4, // Player 0 - centre striker
//	3, 4, // Player 1 - centre striker
//	4, 5, // Player 2 - left wing midfielder
//	3, 5, // Player 3 - centre midfielder
//	3, 5, // Player 4 - centre midfielder
//	2, 5, // Player 5 - right wing midfielder
//	4, 6, // Player 6 - left wing defender
//	3, 6, // Player 7 - centre defender
//	3, 6, // Player 8 - centre defender
//	2, 6  // Player 9 - right wing defender
//	];

// private static int[,] goaliePosition = new int[2, 2] { { 3, 1 }, { 3, 7 } };

var scores[NumberOfTeams] = [0, 0];
hvar frozen = false;

//////////////////////
// Position setting //
//////////////////////

// Set a team to 4-3-3 formation
//Set443(team) = Set443.team { 
//	if (team == 0) {
//		playerPositions[0][0][ROW] = 
//	} else {
//	
//	}
//} -> Skip;

// To manually set a player position
SetPlayerPosition(team, player, row, col) = SetPlayer.team.player { playerPositions = call(setPlayerPosition, playerPositions, team, player, row, col); } -> Skip;

// To manually set a goalie position
//SetGoaliePosition(team, row, col) = SetGoalie.team { call(setGoaliePosition, team, row, col); } -> Skip;

// To manually set a ball position
SetBallPosition(row, col) = SetBall.row.col { ballPosition[0] = row; ballPosition[1] = col; } -> Skip;

// To manually set possession of ball
SetBallPossession(team) = SetPossession.team { possession = team; } -> Skip;

SetBallPlayer(player) = SetBallP.player { ballPlayer = player; } -> Skip; // implement lib

SetKickOffPosition(team) = SetBallPosition(3, 4); SetBallPossession(team); SetPlayerPosition(team, 0, 3, 4); SetBallPlayer(0); // continue adding

SetKickOffAfterOutOfBoundPosition(team) =
	[team == 1] SetBallPosition(3,6); SetBallPossession(team); SetPlayerPosition(team, 9, 3, 6); SetBallPlayer(9)
	[]
	[team == 0] SetBallPosition(3, 2); SetBallPossession(team); SetPlayerPosition(team, 9, 3, 2); SetBallPlayer(9);

////////////////////
// General action //
////////////////////

DecideFirstPossession() = []possess:{0, 1} @ SetKickOffPosition(possess);

TakeAction() = 
    [time > 0] Tick { time--; } -> Unfreeze { frozen = false; } -> MoveAction(); OtherAction(); TakeAction() //CheckBallEvent()
    []
    [time <= 0] Skip;

//////////////////////
// Movement actions //
//////////////////////

MoveAction() = move { playerPositions = call(move, playerPositions, possession, ballPosition, ballPlayer); } -> Skip;

///////////////////
// Other actions //
//////////////////

RetrieveBall() = []team:{0, 1} @ Retrieve.team { possession = call(getBall, playerPositions, team, possession, ballPosition); ballPlayer = call(getBallPlayer, playerPositions, possession, ballPosition); } ->  Skip;

OtherAction() = |||team:{0, 1} @ OtherAct.team -> (
	[!frozen && team == possession] atomic { OffensiveAction() }
	[]
	[!frozen && team != possession && possession != -1] atomic { DefensiveAction() }
	[]
	[!frozen && possession == -1] atomic { RetrieveBall() }
	[]
	[frozen] Skip);

DefensiveAction() = pcase {
	call(getTackleProb, playerPositions, ballPosition, possession): TackleSuccess { ballPlayer = call(getTacklePlayer, playerPositions, ballPosition, possession); if(possession == 1) { possession = 0;} else { possession = 1; } } -> Skip
	call(getDodgeProb, possession, ballPlayer): TackleFail -> Skip
	};

OffensiveAction() = pcase {
	call(getShootProb, possession, ballPlayer, ballPosition): ShootAction -> Shoot()
	call(getPassProb, possession, ballPlayer): PassAction -> Pass() 
	1: Drib -> Dribble() 
	1: DoNothing -> Skip
	};

Dribble() = pcase {
	call(getDribbleProb, possession, ballPlayer): atomic { DribbleSuccess { playerPositions = call(dribble, playerPositions, possession, ballPlayer); ballPosition = call(getDribbleBall, playerPositions, ballPlayer, possession); } -> Skip }
	1: DribbleFail { possession = -1; } -> Skip
    };

Shoot() = pcase {
	call(getScoreProb, possession, ballPlayer): ShootScore { scores[possession]++; playerPositions = call(resetPlayerPosition); if(possession == 1) { possession = 0;} else { possession = 1; } } -> Freeze { frozen = true; } -> SetKickOffPosition(possession) // need to reset afterwards
	call(getOutOfBoundProb, possession, ballPlayer): ShootMissOutOfBounds {  playerPositions = call(resetPlayerPosition); if(possession == 1) { possession = 0;} else { possession = 1; }  } -> Freeze { frozen = true; } -> SetKickOffAfterOutOfBoundPosition(possession) // flip posession and let keeper have the ball
	1: ShootMiss { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1;  } -> Skip
	};

Pass() = pcase { 
    9: PassSuccess { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1;  } -> Skip
    1: PassFailOutOfBound { ballPosition = call(setOutOfBoundThenThrowIn, ballPosition);  if(possession == 1) { possession = 0; } else { possession = 1; } ballPlayer = 0; playerPositions[possession][0][0] = ballPosition[0]; playerPositions[possession][0][1] = ballPosition[1];  } -> Skip                  
    };

PlayMatch() = DecideFirstPossession(); TakeAction();

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert PlayMatch reaches FirstTeamWin;
#assert PlayMatch reaches SecondTeamWin;
#assert PlayMatch reaches Draw;

#assert PlayMatch reaches FirstTeamWin with prob;
#assert PlayMatch reaches SecondTeamWin with prob;
#assert PlayMatch reaches Draw with prob;

#assert PlayMatch deadlockfree;