// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |  top |  top |  top |  top |  top |  top |  top |      |
// +------+------+------+------+------+------+------+------+------+
// |  out |corner|      |      |      |      |      |corner|  out |
// | side | kick |      |      |      |      |      | kick | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// | goal | goal |      |      | start|      |      | goal | goal |
// |   A  |  box |      |      |circle|      |      |  box |   B  | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |corner|      |      |      |      |      |corner|  out |
// | side | kick |      |      |      |      |      | kick | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |bottom|bottom|bottom|bottom|bottom|bottom|bottom|      |
// +------+------+------+------+------+------+------+------+------+

// Gameplay: 11 vs 11 (goalie can only move within the goal box)
// Overall grid size = 7 x 9
// out top/bottom - out of bounds cells needed to keep track of throw-in locations
// out side - out of bounds cells to transition into corner-kick/goal-kick events
// goal box - cells where the goalie can move
// corner kick - cells where corner-kick events take place
// start circle - starting ball/player position whenever there are hard resets
// resets - hard or soft, depending on event
// hard resets - where postions of EVERY player are set to fixed positions. Happens for own goal/score/corner-kick events
// soft resets - where positions of SOME players are manually set. Happens for throw-in events

#import "PAT.Lib.SoccerCalc";

#define PlayersPerTeam 10;
#define RowSize 7;
#define ColumnSize 9;

var time = 10;
hvar ballEvent = 0;
hvar possession = 0; // only used as a temp var to perform OtherAction
var scores = [0, 0];

//////////////////////
// Position setting //
//////////////////////

// To manually set a player position
SetPlayerPosition(team, player, row, col) = SetPlayer.team.player { call(setPlayerPosition, team, player, row, col); } -> Skip;

// To manually set a goalie position
SetGoaliePosition(team, row, col) = SetGoalie.team { call(setGoaliePosition, team, row, col); } -> Skip;

// To manually set a ball position
SetBallPosition(row, col) = SetBall.row.col { call(setBallPosition, row, col); } -> Skip;

// To manually set possession of ball
SetBallPossession(team) = SetPossession.team { call(setPossession, team); } -> Skip;

SetBallPlayer(player) = SetBallPlayer.player { call(setBallPlayer, player); } -> Skip; // implement lib

SetKickOffPosition(team) = SetBallPosition(3, 4); SetBallPossession(team); SetPlayerPosition(team, 0, 3, 4); SetBallPlayer(0); // continue adding

////////////////////
// General action //
////////////////////

DecideFirstPossession() = []possession:{0, 1} @ SetKickOffPosition(possession);

TakeAction() = 
    [time > 0] Tick { time--; } -> MoveAction(); OtherAction(); CheckBallEvent();
    []
    [time <= 0] Skip;

//////////////////////
// Movement actions //
//////////////////////

MoveAction() = move { call(move); } -> Dribble();

Dribble() = pcase {
	call(getDribbleProb): DribbleSuccess { call(dribble); } -> Skip
	1: DribbleFail -> SetBallPossession(-1); RetrieveBall();
    };

///////////////////
// Other actions //
//////////////////

RetrieveBall() = || team:{0, 1} @ RetrieveBall.team -> GetBall(team);

GetBall(team) = GetBall.team { call(getBallDeterministic, team); } -> Skip; // can change to non-deterministic if needed at the end

OtherAction() = ||| team:{0, 1} @ OtherAction.team { possession = call(getPossession); } ->
	[team == possession] OffensiveAction()
	[]
	[team != possession && possession != -1] DefensiveAction()
	[]
	[possession == -1] RetrieveBall();

DefensiveAction() = pcase {
	call(getTackleProb): TackleSuccess { call(updateTackle); } -> Skip
	1: TackleFail -> Skip
	};

OffensiveAction() = pcase {
	call(getShootProb): Shoot -> Shoot() // change to lib call
	call(getPassProb): Pass -> Pass() // change to lib call
	1: DoNothing -> Skip;
	};

Shoot() = pcase {
	call(getShootSuccessProb): ShootScore -> Skip
	1: ShootMiss -> Skip;
	};

Pass() = pcase {
	call(getPassSuccessProb): PassSuccess -> Skip
	1: PassFail -> Skip;
	};

//    
//CheckForBallEvent() = updateBallEvent { ballEvent = call(checkBallEvent, ball, 	, ColumnSize)} ->
//	[ballEvent == 0]
//	[]
//	[ballEvent == 1] Goal()
//	[]
//	[ballEvent == 2] CornerOrGoalKick();
//	[]
//	[ballEvent == 3] changePossession { possession = -1 * possession; } -> ThrowIn(possession);
//
//CornerOrGoalKick() = Skip;
//
//CornerKick() = Skip;
//
//GoalKick() = Skip;
//
//Goal() = Skip;
//
//ThrowIn(i) = findClosestPlayer.i { team[call(closestPlayer, ball)] = ball; } -> Throw(i) -> fsfsf;

PlayMatch = DecideFirstPossession(); SetBallPosition(3, 4); TakeActionMove();

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert PlayMatch reaches FirstTeamWin;
#assert PlayMatch reaches SecondTeamWin;
#assert PlayMatch reaches Draw;

#assert PlayMatch reaches FirstTeamWin with prob;
#assert PlayMatch reaches SecondTeamWin with prob;
#assert PlayMatch reaches Draw with prob;

#assert PlayMatch deadlockfree;