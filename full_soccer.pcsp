// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |  top |  top |  top |  top |  top |  top |  top |      |
// +------+------+------+------+------+------+------+------+------+
// |  out | out  |      |      |      |      |      | out  |  out |
// | side | side |      |      |      |      |      | side | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// | goal | goal |      |      | start|      |      | goal | goal |
// |   A  |  box |      |      |circle|      |      |  box |   B  | 
// +------+------+------+------+------+------+------+------+------+
// |  out | goal |      |      |      |      |      | goal |  out |
// | side |  box |      |      |      |      |      |  box | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out | out  |      |      |      |      |      | out  |  out |
// | side | side |      |      |      |      |      | side | side | 
// +------+------+------+------+------+------+------+------+------+
// |  out |  out |  out |  out |  out |  out |  out |  out |  out |
// |      |bottom|bottom|bottom|bottom|bottom|bottom|bottom|      |
// +------+------+------+------+------+------+------+------+------+

// Gameplay: 11 vs 11 (goalie can only move within the goal box)
// Overall grid size = 7 x 9
// out top/bottom - out of bounds cells needed to keep track of throw-in locations
// out side - out of bounds cells to transition into corner-kick/goal-kick events
// goal box - cells where the goalie can move
// corner kick - cells where corner-kick events take place
// start circle - starting ball/player position whenever there are hard resets
// resets - hard or soft, depending on event
// hard resets - where postions of EVERY player are set to fixed positions. Happens for own goal/score/corner-kick events
// soft resets - where positions of SOME players are manually set. Happens for throw-in events

#import "PAT.Lib.SoccerCalc";

#define NUMBER_OF_TEAMS 2;
#define PLAYERS_PER_TEAM 10;
#define NUMBER_OF_DIMENSIONS 2;
#define ROW 0;
#define COL 1;
#define NUMBER_OF_OFFENSIVE_ACTIONS 3;
#define MIN_COL 1;
#define MAX_COL 7;

hvar formation = 433;
hvar frozen = false;
var time = 7;
var scores[NUMBER_OF_TEAMS] = [0, 0];
var possession = -1;
var ballPlayer = -1;
var ballPosition[NUMBER_OF_DIMENSIONS] = [3, 4]; // Ball always starts in the centre
hvar offenseProbabilities[NUMBER_OF_OFFENSIVE_ACTIONS] = [1, 1, 1]; // [Shoot, Pass, Dribble]
hvar retrieveResult = [0, 0]; // arbitrary
hvar tackleResult = [0, 0];
var playerPositions[NUMBER_OF_TEAMS][PLAYERS_PER_TEAM][NUMBER_OF_DIMENSIONS] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];

//////////////////////
// Position setting //
//////////////////////

// To manually set a player position
_SetPlayerPosition(team, player, row, col) = SetPlayerPosition.team.player.row.col { 
	playerPositions[team][player][ROW] = row;
	playerPositions[team][player][COL] = col;
} -> Skip;

// To manually set a ball position
_SetBallPosition(row, col) = SetBallPosition.row.col { 
	ballPosition[ROW] = row; 
	ballPosition[COL] = col;
} -> Skip;

SetKickOffPosition(team) = ResetPlayerPositions.formation { playerPositions = call(getFormation, formation); } -> SetBallPlayer.1 { ballPlayer = 1; } -> _SetBallPosition(3, 4); _SetPlayerPosition(team, 0, 3, 4); _SetPlayerPosition(team, 1, 3, 4); // 0 and 1 here because typically 2 players kick off

SetAfterGoalKickPosition(team) =
	[team == 1] SetBallPlayer.8 { ballPlayer = 8; } -> _SetBallPosition(3, MAX_COL); _SetPlayerPosition(team, 8, 3, MAX_COL)
	[]
	[team == 0] SetBallPlayer.8 { ballPlayer = 8; } -> _SetBallPosition(3, MIN_COL); _SetPlayerPosition(team, 8, 3, MIN_COL)
;

////////////////////
// General action //
////////////////////

DecideFirstPossession() = []team:{0, 1} @ GivePossession.team { possession = team; } -> Skip;

TakeAction() =
    [time > 0] Tick { time--; } -> Unfreeze { frozen = false; } -> _Move(); OtherAction(); TakeAction()
    []
    [time <= 0] Skip;

//////////////////////
// Movement actions //
//////////////////////

_Move() = Move { playerPositions = call(move, playerPositions, possession, ballPosition, ballPlayer); } -> Skip;

///////////////////
// Other actions //
//////////////////

RetrieveBall() = []team:{0, 1} @ Retrieve.team { retrieveResult = call(getBall, playerPositions, team, possession, ballPosition); possession = retrieveResult[0]; ballPlayer = retrieveResult[1]; } -> Skip;

OtherAction() = |||team:{0, 1} @ OtherAct.team -> (
	[!frozen && team == possession] atomic { OffensiveAction() }
	[]
	[!frozen && team != possession && possession != -1] atomic { DefensiveAction() }
	[]
	[!frozen && possession == -1] atomic { RetrieveBall() }
	[]
	[frozen] Skip
);

DefensiveAction() = Tackle { tackleResult = call(tackle, playerPositions, ballPosition, possession, ballPlayer); possession = tackleResult[0]; ballPlayer = tackleResult[1]; } -> Skip;

OffensiveAction() = UpdateOffenseProbabilities { offenseProbabilities = call(getOffenseProbabilities, possession, ballPosition, playerPositions) } -> pcase {
	offenseProbabilities[0]: Shoot -> _Shoot()
	offenseProbabilities[1]: Pass -> _Pass()
	offenseProbabilities[2]: Dribble -> _Dribble()
};

_Dribble() = pcase {
	9: DribbleSuccess { playerPositions = call(dribble, playerPositions, possession, ballPlayer); ballPosition[0] = playerPositions[possession][ballPlayer][0]; ballPosition[1] = playerPositions[possession][ballPlayer][1]; } -> Skip
	1: DribbleFail { possession = -1; ballPlayer = -1; } -> Skip
};

_Shoot() = pcase {
	call(getScoreProb, possession, ballPlayer): Score.possession { scores[possession]++; playerPositions = call(getFormation, formation); possession = (possession + 1) % 2; } -> Freeze { frozen = true; } -> SetKickOffPosition(possession)
	call(getOutOfBoundsProb, possession, ballPlayer): ShootOutOfBounds { playerPositions = call(getFormation, formation); possession = (possession + 1) % 2; } -> Freeze { frozen = true; } -> SetAfterGoalKickPosition(possession)
	call(getMissProb, possession, ballPlayer): Miss { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1; } -> Skip
};

_Pass() = Pass { ballPosition = call(setPassTarget, possession, ballPosition); possession = -1; ballPlayer = -1; } -> Skip;

PlayMatch() = DecideFirstPossession(); SetKickOffPosition(possession); TakeAction();

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

//#assert PlayMatch() reaches FirstTeamWin;
//#assert PlayMatch() reaches SecondTeamWin;
//#assert PlayMatch() reaches Draw;

#assert PlayMatch() reaches FirstTeamWin with prob;
#assert PlayMatch() reaches SecondTeamWin with prob;
#assert PlayMatch() reaches Draw with prob;

//#assert PlayMatch() deadlockfree;