// +-----+-----+-----+-----+-----+
// |     |  2  |  3  |  4  |     |
// +-----+-----+-----+-----+-----+
// |  1  |  5  |  6  |  7  |  11 |
// +-----+-----+-----+-----+-----+
// |     |  8  |  9  |  10 |     |
// +-----+-----+-----+-----+-----+
// 1 is team 0 goal
// 11 is team 1 goal
// 0 is out of bounds

enum {
	NEUTRAL,
	OFFENSIVE,
	DEFENSIVE
};

var time = 2;
hvar ball[2] = [0, 0];
hvar possession = -1; // initially, undecided possession
var scores = [0, 0];
hvar positions[2][2][2] = [0, 0, 0, 0, 0, 0, 0, 0];
hvar action_probabilities[2][5] = [
	10, 1, 9, 50, 30, // [Score, OwnGoal, MissKeepPossession, MissChangePossession, OutOfBounds]
	20, 1, 4, 50, 25 // each row must add up to 100
];
hvar strategies = [NEUTRAL, NEUTRAL];

_DribbleLeft(i, j) = DribbleLeft.i.j {
	ball[1]--;
	positions[i][j][1]--;
} -> Skip;

_DribbleUp(i, j) = DribbleUp.i.j {
	ball[0]--;
	positions[i][j][0]--;
} -> Skip;

_DribbleRight(i, j) = DribbleRight.i.j {
	ball[1]++;
	positions[i][j][1]++;
} -> Skip;

_DribbleDown(i, j) = DribbleDown.i.j {
	ball[0]++;
	positions[i][j][0]++;
} -> Skip;

_MoveLeft(i, j) = MoveLeft.i.j {
	positions[i][j][1]--;
} -> Skip;

_MoveUp(i, j) = MoveUp.i.j {
	positions[i][j][0]--;
} -> Skip;

_MoveRight(i, j) = MoveRight.i.j {
	positions[i][j][1]++;
} -> Skip;

_MoveDown(i, j) = MoveDown.i.j {
	positions[i][j][0]++;
} -> Skip;

MoveTowardsBall(i, j) = if (positions[i][j][0] == ball[0] && positions[i][j][1] == ball[1]) {
	// Same position as ball, no need to move
	Skip
} else if (positions[i][j][0] > ball[0] && positions[i][j][1] == ball[1]) {
	// Above the ball
	_MoveUp(i, j)
} else if (positions[i][j][0] < ball[0] && positions[i][j][1] == ball[1]) {
	// Below the ball
	_MoveDown(i, j)
} else if (positions[i][j][0] == ball[0] && positions[i][j][1] < ball[1]) {
	// Left of ball
	_MoveRight(i, j)
} else if (positions[i][j][0] == ball[0] && positions[i][j][1] > ball[1]) {
	// Right of ball
	_MoveLeft(i, j)
} else if (positions[i][j][0] > ball[0] && positions[i][j][1] > ball[1]) {
	// Bottom right of ball
	atomic {
		_MoveLeft(i, j);
		_MoveUp(i, j)
	}
} else if (positions[i][j][0] > ball[0] && positions[i][j][1] < ball[1]) {
	// Bottom left of ball
	atomic {
		_MoveRight(i, j);
		_MoveUp(i, j)
	}
} else if (positions[i][j][0] < ball[0] && positions[i][j][1] < ball[1]) {
	// Top left of ball
	atomic {
		_MoveRight(i, j);
		_MoveDown(i, j)
	}
} else if (positions[i][j][0] < ball[0] && positions[i][j][1] > ball[1]) {
	// Top right of ball
	atomic {
		_MoveLeft(i, j);
		_MoveDown(i, j)
	}
};

Move(i, j) = 
	[strategies[i] == NEUTRAL] _MoveRight(i, j)
	[]
	[strategies[i] == OFFENSIVE] _MoveLeft(i, j)
	[]
	[strategies[i] == DEFENSIVE] _MoveUp(i, j)
;

_ResetBall = ResetBall {
	ball[0] = 1;
	ball[1] = 1;
} -> Skip;

_ResetTeamPositions(i) = ResetTeamPositions.i {
	if (i == 0) {
		positions[0][0][0] = 0;
		positions[0][0][1] = 0;
		positions[0][1][0] = 2;
		positions[0][1][1] = 0;
	} else if (i == 1) {
		positions[1][0][0] = 0;
		positions[1][0][1] = 2;
		positions[1][1][0] = 2;
		positions[1][1][1] = 2;
	}
} -> Skip;

_ResetPositions = atomic {
	_ResetBall; _ResetTeamPositions(0); _ResetTeamPositions(1)
};

_ChangePossession = ChangePossession {
	possession = (possession + 1) % 2;
} -> Skip;

TakePossession(i) = []j:{0, 1} @ [positions[i][j][0] == ball[0] && positions[i][j][1] == ball[1]] {
	possession = i
} -> Skip;

Shoot(i) = if (possession == i) {
	atomic {
		pcase {
			action_probabilities[i][0]: Score.i {
				scores[i]++;
			} -> (_ResetPositions; _ChangePossession)
		
			action_probabilities[i][1]: OwnGoal.i {
				scores[(i + 1) % 2]++;
			} -> (_ResetPositions; _ChangePossession)
			
			action_probabilities[i][2]: MissKeepPossession.i -> Skip
			
			action_probabilities[i][3]: MissChangePossession.i -> (_ResetBall; _ChangePossession)
			
			action_probabilities[i][4]: OutOfBounds.i -> (_ResetPositions; _ChangePossession)
		}
	}
};

TakeTeamAction(i) = |||j:{0, 1} @ Move(i, j);
//||| Shoot(i);

TakeAction = [time > 0] Tick { time--; } -> (TakeTeamAction(0) ||| TakeTeamAction(1)); TakeAction
	[] [time <= 0] Skip;

PlayGame = _ResetPositions; TakeAction;

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert PlayGame reaches FirstTeamWin;
#assert PlayGame reaches SecondTeamWin;
#assert PlayGame reaches Draw;

#assert PlayGame reaches FirstTeamWin with prob;
#assert PlayGame reaches SecondTeamWin with prob;
#assert PlayGame reaches Draw with prob;

#assert PlayGame deadlockfree;