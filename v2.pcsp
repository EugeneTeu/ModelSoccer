/*
Naming conventions: 
	processes are PascalCase and start with _
	events are PascalCase and do not start with _
	variables are snake_case
*/

// +-----+-----+-----+-----+-----+
// |     |  2  |  3  |  4  |     |
// +-----+-----+-----+-----+-----+
// |  1  |  5  |  6  |  7  |  11 |
// +-----+-----+-----+-----+-----+
// |     |  8  |  9  |  10 |     |
// +-----+-----+-----+-----+-----+
// 1 is team 0 goal
// 11 is team 1 goal
// 0 is out of bounds

enum {
	NEUTRAL,
	OFFENSIVE,
	DEFENSIVE
};

var time = 1;
hvar ball_position[2] = [1, 1];
hvar possession[2] = [-1, -1]; // initially, undecided possession
var scores = [0, 0];
hvar positions[2][2][2] = [0, 0, 0, 0, 0, 0, 0, 0];
hvar shoot_probabilities[2][3] = [
	10, 5, 85, // [Score, HitGoalPost, OutOfBounds]
	20, 5, 75  // each row must add up to 100
];
hvar strategies = [NEUTRAL, NEUTRAL];
hvar frozen = false;

_Freeze = Freeze { frozen = true; } -> Skip;
_Unfreeze = Unfreeze { frozen = false; } -> Skip;

_ResetBall = ResetBall {
	ball_position[0] = 1;
	ball_position[1] = 1;
} -> Skip;

_SetDefaultPositions(team) = SetDefaultPositions.team {
	if (team == 0) {
		positions[0][0][0] = 0;
		positions[0][0][1] = 0;
		positions[0][1][0] = 2;
		positions[0][1][1] = 0;
	} else if (team == 1) {
		positions[1][0][0] = 0;
		positions[1][0][1] = 2;
		positions[1][1][0] = 2;
		positions[1][1][1] = 2;
	}
} -> Skip;

_SetKickoffPositions(team) = SetKickoffPositions.team {
	positions[team][0][0] = 1;
	positions[team][0][1] = 1;
	positions[team][1][0] = 1;
	positions[team][1][1] = 1;
} -> Skip;

_Reset = _ResetBall; (
	[possession[0] == 0] _SetDefaultPositions(1); _SetKickoffPositions(0)
	[]
	[possession[0] == 1] _SetDefaultPositions(0); _SetKickoffPositions(1)
);

_GetTeamPossession(team) = []player:{0, 1} @ _GetPossession(team, player);

_GetPossession(team, player) = GetPossession.team.player {
	// We update strategies here so that this process can be directly used
	strategies[team] = OFFENSIVE;
	strategies[(team + 1) % 2] = DEFENSIVE;
	possession[0] = team;
	possession[1] = player;
} -> Skip;

_ChangePossession =
	[possession[0] == 0] _GetTeamPossession(1)
	[]
	[possession[0] == 1] _GetTeamPossession(0)
;

_DribbleLeft(team, player) = DribbleLeft.team.player {
	ball_position[1]--;
	positions[team][player][1]--;
} -> Skip;

_DribbleUp(team, player) = DribbleUp.team.player {
	ball_position[0]--;
	positions[team][player][0]--;
} -> Skip;

_DribbleRight(team, player) = DribbleRight.team.player {
	ball_position[1]++;
	positions[team][player][1]++;
} -> Skip;

_DribbleDown(team, player) = DribbleDown.team.player {
	ball_position[0]++;
	positions[team][player][0]++;
} -> Skip;

_DribbleUpLeft(team, player) = DribbleUpLeft.team.player {
	ball_position[0]--;
	ball_position[1]--;
	positions[team][player][0]--;
	positions[team][player][1]--;
} -> Skip;

_DribbleUpRight(team, player) = DribbleUpRight.team.player {
	ball_position[0]--;
	ball_position[1]++;
	positions[team][player][0]--;
	positions[team][player][1]++;
} -> Skip;

_DribbleDownLeft(team, player) = DribbleDownLeft.team.player {
	ball_position[0]++;
	ball_position[1]--;
	positions[team][player][0]++;
	positions[team][player][1]--;
} -> Skip;

_DribbleDownRight(team, player) = DribbleDownRight.team.player {
	ball_position[0]++;
	ball_position[1]++;
	positions[team][player][0]++;
	positions[team][player][1]++;
} -> Skip;

_DribbleTowardsOpponentGoal(team, player) =
	[team == 0 && positions[team][player][1] != 2] _DribbleRight(team, player)
	[]
	[team == 0 && positions[team][player][1] == 2] Stay.team.player -> Skip
	[]
	[team == 1 && positions[team][player][1] != 0] _DribbleLeft(team, player)
	[]
	[team == 1 && positions[team][player][1] == 0] Stay.team.player -> Skip
;

_Dribble(team, player) = 
	// Right now, any player who has the right to dribble must be in OFFENSIVE mode
	[strategies[team] == NEUTRAL] Skip
	[]
	[strategies[team] == OFFENSIVE] _DribbleTowardsOpponentGoal(team, player)
	[]
	[strategies[team] == DEFENSIVE] Skip
;

_Tackle(team, player) = pcase {
	[0.2]: atomic { SuccessfulTackle.team.player -> _GetPossession(team, player) }
	[0.8]: atomic { UnsuccessfulTackle.team.player -> Skip }
};

_MoveLeft(team, player) = MoveLeft.team.player {
	positions[team][player][1]--;
} -> Skip;

_MoveUp(team, player) = MoveUp.team.player {
	positions[team][player][0]--;
} -> Skip;

_MoveRight(team, player) = MoveRight.team.player {
	positions[team][player][1]++;
} -> Skip;

_MoveDown(team, player) = MoveDown.team.player {
	positions[team][player][0]++;
} -> Skip;

_MoveUpLeft(team, player) = MoveUpLeft.team.player {
	positions[team][player][0]--;
	positions[team][player][1]--;
} -> Skip;

_MoveUpRight(team, player) = MoveUpRight.team.player {
	positions[team][player][0]--;
	positions[team][player][1]++;
} -> Skip;

_MoveDownLeft(team, player) = MoveDownLeft.team.player {
	positions[team][player][0]++;
	positions[team][player][1]--;
} -> Skip;

_MoveDownRight(team, player) = MoveDownRight.team.player {
	positions[team][player][0]++;
	positions[team][player][1]++;
} -> Skip;

_MoveTowardsBall(team, player) =
	[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] Stay.team.player -> Skip
	[]
	[positions[team][player][0] > ball_position[0] && positions[team][player][1] == ball_position[1]] _MoveUp(team, player)
	[]
	[positions[team][player][0] < ball_position[0] && positions[team][player][1] == ball_position[1]] _MoveDown(team, player)
	[]
	[positions[team][player][0] == ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveRight(team, player)
	[]
	[positions[team][player][0] == ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveLeft(team, player)
	[]
	[positions[team][player][0] > ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveUpLeft(team, player)
	[]
	[positions[team][player][0] > ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveUpRight(team, player)
	[]
	[positions[team][player][0] < ball_position[0] && positions[team][player][1] < ball_position[1]] _MoveDownRight(team, player)
	[]
	[positions[team][player][0] < ball_position[0] && positions[team][player][1] > ball_position[1]] _MoveDownLeft(team, player)
;

_MoveTowardsOpponentGoal(team, player) =
	[team == 0 && positions[team][player][1] != 2] _MoveRight(team, player)
	[]
	[team == 0 && positions[team][player][1] == 2] Stay.team.player -> Skip
	[]
	[team == 1 && positions[team][player][1] != 0] _MoveLeft(team, player)
	[]
	[team == 1 && positions[team][player][1] == 0] Stay.team.player -> Skip
;

_Move(team, player) = 
	[strategies[team] == NEUTRAL] 
		_MoveTowardsBall(team, player); (
			[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] atomic { _GetPossession(team, player) }
			[]
			[positions[team][player][0] != ball_position[0] || positions[team][player][1] != ball_position[1]] atomic { Wait.team.player -> Skip }
		)
	[]
	[strategies[team] == OFFENSIVE] _MoveTowardsOpponentGoal(team, player)
	[]
	[strategies[team] == DEFENSIVE] 
		_MoveTowardsBall(team, player); (
			[positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] atomic { _Tackle(team, player) }
			[]
			[positions[team][player][0] != ball_position[0] || positions[team][player][1] != ball_position[1]] atomic { Wait.team.player -> Skip }
		)
;

_LooseBall = atomic { LosePossession { 
	possession[0] = -1;
	possession[1] = -1;
	strategies[0] = NEUTRAL;
	strategies[1] = NEUTRAL;
} -> pcase {
	1: SetBall.0.0 { ball_position[0] = 0; ball_position[1] = 0; } -> Skip
	1: SetBall.0.1 { ball_position[0] = 0; ball_position[1] = 1; } -> Skip
	1: SetBall.0.2 { ball_position[0] = 0; ball_position[1] = 2; } -> Skip
	1: SetBall.1.0 { ball_position[0] = 1; ball_position[1] = 0; } -> Skip
	1: SetBall.1.1 { ball_position[0] = 1; ball_position[1] = 1; } -> Skip
	1: SetBall.1.2 { ball_position[0] = 1; ball_position[1] = 2; } -> Skip
	1: SetBall.2.0 { ball_position[0] = 2; ball_position[1] = 0; } -> Skip
	1: SetBall.2.1 { ball_position[0] = 2; ball_position[1] = 1; } -> Skip
	1: SetBall.2.2 { ball_position[0] = 2; ball_position[1] = 2; } -> Skip
}};

_Shoot(team, player) = pcase {
	shoot_probabilities[team][0]: atomic { Score.team {
		scores[team]++;
	} -> _Freeze; _ChangePossession; _Reset }

	shoot_probabilities[team][1]: atomic { HitGoalPost.team -> _LooseBall }
	
	shoot_probabilities[team][2]: atomic { OutOfBounds.team -> GoalKick.team -> _LooseBall }
};

_TakeTeamAction(team) = |||player:{0, 1} @ (
	[!frozen && (possession[0] != team || possession[1] != player)] _Move(team, player)
	[]
	[!frozen && possession[0] == team && possession[1] == player] _Dribble(team, player)
	[]
	[!frozen && possession[0] == team && possession[1] == player] _Shoot(team, player)
//	[]
//	[!frozen && (possession[0] != team || possession[1] != player) && strategies[team] == DEFENSIVE && positions[team][player][0] == ball_position[0] && positions[team][player][1] == ball_position[1]] _Tackle(team, player)
//	[]
//	[possession[0] == team && possession[1] == player] _Pass(team, player)
	[]
	[frozen] Wait.team.player -> Skip
);

_TakeAction =
	[time > 0] Tick { time--; } -> _Unfreeze; (_TakeTeamAction(0) ||| _TakeTeamAction(1)); _TakeAction
	[]
	[time <= 0] Skip;

_DecideFirstPossession = []team:{0, 1} @ _GetTeamPossession(team);

_PlayGame = _DecideFirstPossession; _Reset; _TakeAction;

#define FirstTeamWin scores[0] > scores[1] && time <= 0;
#define SecondTeamWin scores[1] > scores[0] && time <= 0;
#define Draw scores[0] == scores[1] && time <= 0;

#assert _PlayGame reaches FirstTeamWin;
#assert _PlayGame reaches SecondTeamWin;
#assert _PlayGame reaches Draw;

#assert _PlayGame reaches FirstTeamWin with prob;
#assert _PlayGame reaches SecondTeamWin with prob;
#assert _PlayGame reaches Draw with prob;

#assert _PlayGame deadlockfree;